//Version where smaller cliques are inserted into bigger ones.
	template<typename real>
	real GeneratorPseudoBoolean<real>::minimize_version_3(vector<label>& x, int& nlabelled) const
	{
		cout << "#########################"<< endl;
		cout <<"inside minimize_3" << endl;
		cout << "#########################"<< endl;
		//maps with elements if generator already added.
		map<triple, int> inserted3;   
		map<pair, int> inserted2;

		//ASSERT_STR(this->gen.ngen4 == 0, "Degree-4 generators are not yet supported.");

		index nVars = index( x.size() ); // Number of variables.
		int n = 2 * nVars;  // Because we have x and y.
		int num_cliques = 0;


		for (auto itr = alphaijkl.begin(); itr != alphaijkl.end(); ++itr) {
			const auto& vec = itr->second;
			for (int ii = 0; ii < std::max(gen.ngen4pos, gen.ngen4neg); ++ii) {
				real alpha = vec.at(ii);
				if (alpha > 0) {
					// Add monomials for this generator to the graph
					num_cliques++;
				}
			}
		}

		real C = 0; // Constant in objective function.
		int clique_size = 4;
		int num_cliques_per_node = 2 * num_cliques; // TODO: Fix this. (Is this parameter used by GC?)

		// We add two extra variables in order to be able to add degree-2 cliques
		// as degree-4 cliques.

		typedef PRGC GCType;
		//typedef APGC GCType;

		GCType graph(n + 2,
			2 * num_cliques, // Each generator gives two cliques.
			clique_size,
			num_cliques_per_node);
		int extra1 = n;
		int extra2 = n + 1;

		std::unique_ptr<PseudoBoolean<real>> f_debug;

		// Uncomment this line to also minimize g exhaustively.
		//f_debug.reset(new PseudoBoolean<real>);

		//
		// Degree-1 terms.
		//
		for (auto itr = alphai.begin(); itr != alphai.end(); ++itr) {
			int i = itr->first;
			real alpha = itr->second;

			graph.AddUnaryTerm(i,         0,     alpha);
			graph.AddUnaryTerm(i + nVars, alpha,     0);

			if (f_debug) {
				f_debug->add_clique(i, 0, alpha);
				f_debug->add_clique(i + nVars, alpha, 0);
			}
		}
		
		
		
		//
		// Go through all alphas which correspond to quartic generators
		//

		for (auto itr = alphaijkl.begin(); itr != alphaijkl.end(); ++itr) {

			cout << "alphaijkl.size= " <<alphaijkl.size()  << endl;

			float E[16];
			const quad& ind = itr->first;
			int i=get_i(ind);
			int j=get_j(ind);
			int k=get_k(ind);
			int l=get_l(ind);
			const auto& vec = itr->second;

			vector<int> idx(8); // Translates from "local" indices to "global"
			idx.at(0) = i; // x variables
			idx.at(1) = j;
			idx.at(2) = k;
			idx.at(3) = l;
			idx.at(4) = i + nVars; // y variables
			idx.at(5) = j + nVars;
			idx.at(6) = k + nVars;
			idx.at(7) = l + nVars;

			// Was a positive or negative generator used?
			bool pos = false;
			auto mitr = posgen4.find(ind);
			if (mitr != posgen4.end()) {
				pos = mitr->second;
			}

			ASSERT(gen.ngen4pos == gen.ngen4neg);
			// The code below assumes a clique size of 4.
			ASSERT(clique_size == 4);
			
			for (int i=0;i<gen.ngen4pos;++i) {
				//cout << "gen.ngen4pos: " << gen.ngen4pos << endl;	
				real alpha = vec.at(i);

				if (alpha > 0) {
					cout << "i: " << i << endl; 

					if (pos) 
					{
						cout << GREEN<< "POSITIVE GENERATOR:" <<NORMAL  << endl;

						// Positive generator was used
						auto& generator = gen.gen4pos.at(i);
						int ii, jj, kk, ll;

						//first part och the symmetric generator.
						ii = idx.at(generator.indices1.at(0));
						jj = idx.at(generator.indices1.at(1));
						kk = idx.at(generator.indices1.at(2));
						ll = idx.at(generator.indices1.at(3));
						
						//creates the fourth-order klick E
						add_generators_to_clique(alpha, E, generator.values1);
						
						cout << "ii: " << ii <<" " << "jj: " << jj <<" " << "kk: " << kk <<" " << "ll: " << ll << endl;
						cout << WHITE << "FIRST PART" << NORMAL << endl;

						
						/////////Adding all positive-first triples!////////
						add_triplet(123,ii, jj, kk, E, inserted3, nVars);
						add_triplet(124,ii, jj, ll, E, inserted3, nVars);
						add_triplet(134,ii, kk, ll, E, inserted3, nVars);
						add_triplet(234,jj, kk, ll, E, inserted3, nVars);

						/////////Adding all positive-first pairs!////////
						add_pair(12,ii,jj,E,inserted2,nVars);
						add_pair(13,ii,kk,E,inserted2,nVars);
						add_pair(14,ii,ll,E,inserted2,nVars);
						add_pair(23,jj,kk,E,inserted2,nVars);
						add_pair(24,jj,ll,E,inserted2,nVars);
						add_pair(34,kk,ll,E,inserted2,nVars);

						//SYMMETRIC PART 2
						ii = idx.at(generator.indices2.at(0));
						jj = idx.at(generator.indices2.at(1));
						kk = idx.at(generator.indices2.at(2));
						ll = idx.at(generator.indices2.at(3));
						
						//creates the fourth-order klick E
						add_generators_to_clique(alpha, E, generator.values2);
						
						cout << "ii: " << ii <<" " << "jj: " << jj <<" " << "kk: " << kk <<" " << "ll: " << ll << endl;
						cout << WHITE << "SECOND PART:" << NORMAL << endl;
						
						/////////Adding all positive-second triples!////////
						add_triplet(123,ii, jj, kk, E, inserted3, nVars);
						add_triplet(124,ii, jj, ll, E, inserted3, nVars);
						add_triplet(134,ii, kk, ll, E, inserted3, nVars);
						add_triplet(234,jj, kk, ll, E, inserted3, nVars);


						/////////Adding all positive-second pairs!////////
						add_pair(12,ii,jj,E,inserted2,nVars);
						add_pair(13,ii,kk,E,inserted2,nVars);
						add_pair(14,ii,ll,E,inserted2,nVars);
						add_pair(23,jj,kk,E,inserted2,nVars);
						add_pair(24,jj,ll,E,inserted2,nVars);
						add_pair(34,kk,ll,E,inserted2,nVars);


						int indices[] = {ii, jj, kk, ll};
						C += make_clique_positive(4, E);
						graph.AddHigherTerm(indices, E);
						

					}
					else 
					{
						cout << GREEN<< "NEGATIVE GENERATOR" <<NORMAL  << endl;

						// Negative generator was used
						auto& generator = gen.gen4neg.at(i);
						int ii, jj, kk, ll;

						//first part och the symmetric generator.
						ii = idx.at(generator.indices1.at(0));
						jj = idx.at(generator.indices1.at(1));
						kk = idx.at(generator.indices1.at(2));
						ll = idx.at(generator.indices1.at(3));
						
						//creates the fourth-order klick E
						add_generators_to_clique(alpha, E, generator.values1);
						
						cout << "ii: " << ii <<" " << "jj: " << jj <<" " << "kk: " << kk <<" " << "ll: " << ll << endl;
						cout << WHITE << "FIRST PART" << NORMAL << endl;
						

						/////////Adding all negative-first triples!////////
						add_triplet(123,ii, jj, kk, E, inserted3, nVars);
						add_triplet(124,ii, jj, ll, E, inserted3, nVars);
						add_triplet(134,ii, kk, ll, E, inserted3, nVars);
						add_triplet(234,jj, kk, ll, E, inserted3, nVars);

						/////////Adding all negative-first pairs!////////
						add_pair(12,ii,jj,E,inserted2,nVars);
						add_pair(13,ii,kk,E,inserted2,nVars);
						add_pair(14,ii,ll,E,inserted2,nVars);
						add_pair(23,jj,kk,E,inserted2,nVars);
						add_pair(24,jj,ll,E,inserted2,nVars);
						add_pair(34,kk,ll,E,inserted2,nVars);


						//SYMMETRIC PART 2
						ii = idx.at(generator.indices2.at(0));
						jj = idx.at(generator.indices2.at(1));
						kk = idx.at(generator.indices2.at(2));
						ll = idx.at(generator.indices2.at(3));
						
						//creates the fourth-order klick E
						add_generators_to_clique(alpha, E, generator.values2);
						
						cout << "ii: " << ii <<" " << "jj: " << jj <<" " << "kk: " << kk <<" " << "ll: " << ll << endl;
						cout << WHITE << "SECOND PART:" << NORMAL << endl;
						
						/////////Adding all negative-second triples!////////
						add_triplet(123,ii, jj, kk, E, inserted3, nVars);
						add_triplet(124,ii, jj, ll, E, inserted3, nVars);
						add_triplet(134,ii, kk, ll, E, inserted3, nVars);
						add_triplet(234,jj, kk, ll, E, inserted3, nVars);


						/////////Adding all negative-second pairs!////////
						add_pair(12,ii,jj,E,inserted2,nVars);
						add_pair(13,ii,kk,E,inserted2,nVars);
						add_pair(14,ii,ll,E,inserted2,nVars);
						add_pair(23,jj,kk,E,inserted2,nVars);
						add_pair(24,jj,ll,E,inserted2,nVars);
						add_pair(34,kk,ll,E,inserted2,nVars);


						int indices[] = {ii, jj, kk, ll};
						C += make_clique_positive(4, E);
						graph.AddHigherTerm(indices, E);
						

					}
				}
			}
		}


		// all all 3 cliques that is not matched.
		for (auto itr = alphaijk.begin(); itr != alphaijk.end(); ++itr) {
			int ii,jj,kk;
			const triple& ind = itr->first;
			int i=get_i(ind);
			int j=get_j(ind);
			int k=get_k(ind);
			//	cout<<"#################################:       " << "i: " << i << " j: " << j << " k: " << k << endl;


			vector<int> idx(6); // Translates from "local" indices to "global"
			idx.at(0) = i; // x variables
			idx.at(1) = j;
			idx.at(2) = k;
			idx.at(3) = i + nVars; // y variables
			idx.at(4) = j + nVars;
			idx.at(5) = k + nVars;

			const auto& vec = itr->second;
			for (int iii=0;iii<gen.ngen3;++iii) {
				real alpha = vec.at(iii);
				auto& generator = gen.gen3.at(iii);
				ii = idx.at(generator.indices1.at(0));
				jj = idx.at(generator.indices1.at(1));
				kk = idx.at(generator.indices1.at(2));


				auto& itr1 = inserted3.find(make_triple(ii,jj,kk));


				if (alpha > 0) {
					// Add cliques for this generator to the graph

					if (itr1->second == 2) {
						cout << RED << "Extra triple added nbr1:   ii:  " << ii <<" " << "jj    " << jj <<" " << "kk :  " << kk << NORMAL <<  endl;
						float E1[]= {alpha * generator.values1.at(0), // E0000
							alpha * generator.values1.at(1), // E0001
							alpha * generator.values1.at(2), // E0010
							alpha * generator.values1.at(3), // E0011
							alpha * generator.values1.at(4), // E0100
							alpha * generator.values1.at(5), // E0101
							alpha * generator.values1.at(6), // E0110
							alpha * generator.values1.at(7), // E0111
							alpha * generator.values1.at(0), // E1000
							alpha * generator.values1.at(1), // E1001
							alpha * generator.values1.at(2), // E1010
							alpha * generator.values1.at(3), // E1011
							alpha * generator.values1.at(4), // E1100
							alpha * generator.values1.at(5), // E1101
							alpha * generator.values1.at(6), // E1110
							alpha * generator.values1.at(7)};// E1111
						int indices1[] = {extra1,
							idx.at(generator.indices1.at(0)),
							idx.at(generator.indices1.at(1)),
							idx.at(generator.indices1.at(2))};
						C += make_clique_positive(clique_size, E1);
						graph.AddHigherTerm(indices1, E1);
					}

					if(itr1->second ==1){
						cout << RED << "Extra triple added nbr2:   ii:  " << ii <<" " << "jj    " << jj <<" " << "kk :  " << kk << NORMAL <<  endl;
						float E2[]= {alpha * generator.values2.at(0), // E0000
							alpha * generator.values2.at(1), // E0001
							alpha * generator.values2.at(2), // E0010
							alpha * generator.values2.at(3), // E0011
							alpha * generator.values2.at(4), // E0100
							alpha * generator.values2.at(5), // E0101
							alpha * generator.values2.at(6), // E0110
							alpha * generator.values2.at(7), // E0111
							alpha * generator.values2.at(0), // E1000
							alpha * generator.values2.at(1), // E1001
							alpha * generator.values2.at(2), // E1010
							alpha * generator.values2.at(3), // E1011
							alpha * generator.values2.at(4), // E1100
							alpha * generator.values2.at(5), // E1101
							alpha * generator.values2.at(6), // E1110
							alpha * generator.values2.at(7)};// E1111
						int indices2[] = {extra1,
							idx.at(generator.indices2.at(0)),
							idx.at(generator.indices2.at(1)),
							idx.at(generator.indices2.at(2))};
						C += make_clique_positive(clique_size, E2);
						graph.AddHigherTerm(indices2, E2);

						cout << endl;
					}
					//if itr1-second == 3... they are already added.

				}
			}
		}

		double min_g = constant + C + graph.FindMaxFlow();
		vector<label> xfull(n);
		for (int i = 0; i < n; ++i) {
			xfull[i] = graph.GetLabel(i);
		}

		if (f_debug) {
			std::cout << "Generic cuts\n";
			std::cout << "C=" << C << " min_g=" << min_g << "\n";

			for (int i = 0; i < nVars; ++i) {
				std::cout << xfull[i];
			}
			std::cout << ", ";
			for (int i = 0; i < nVars; ++i) {
				std::cout << xfull[i + nVars];
			}
			std::cout << "\n";
		}

		nlabelled = 0;
		for (int i=0; i<nVars; ++i) {
			bool used = false;
			auto itr = var_used.find(i);
			if (itr != var_used.end()) {
				used = itr->second;
			}

			if (used) {
				x[i]     = xfull[i];
				label yi = xfull[i+nVars];
				if (x[i] == yi) {
					x[i] = -1;
				}
				else {
					nlabelled++;
				}
			}
			else {
				// This variable is not part of the polynomial,
				// therefore labelled
				if (x[i]<0) {
					x[i]=0;
				}
				nlabelled++;
			}
		}


		if (f_debug) {
			//
			// Minimize f_debug with exhaustive search.
			//
			vector<label> x_debug(n + 2, 0), x_debug_opt(n + 2, 0);
			real optimum = f_debug->eval(x_debug);
			while (true) {
				x_debug[0]++;
				int i=0;
				while (x_debug[i]>1) {
					x_debug[i]=0;
					i++;
					if (i == n + 2) {
						break;
					}
					x_debug[i]+=1;
				}
				if (i == n + 2) {
					break;
				}

				real energy = f_debug->eval(x_debug);
				if (energy < optimum) {
					optimum = energy;
					x_debug_opt = x_debug;
				}
			}

			std::cout << "Exhaustive debug\n";
			std::cout << "C=" << C << " min_f_debug=" << constant + C + optimum << "\n";
			for (int i = 0; i < nVars; ++i) {
				std::cout << x_debug_opt[i];
			}
			std::cout << ", ";
			for (int i = 0; i < nVars; ++i) {
				std::cout << x_debug_opt[i + nVars];
			}
			std::cout << "\n";
		}

		return min_g;
	}
	
	
	
	
	
	make_triple(3,2,1);

		//iterator on the "global" index (check so exaclty the same is not added before) 1 means first part, 2 second

		auto itr1 = inserted3.find(make_triple(ii, jj, kk));
		int ii2 = ii;
		int jj2 = jj;
		int kk2 = kk;

		//to find the right alphaijk
		if (ii2> nVars-1)
			ii2 -= nVars;
		if (jj2> nVars-1)
			jj2 -= nVars;
		if (kk2> nVars-1)
			kk2 -= nVars;

		auto itr = alphaijk.find(make_triple(ii2, jj2, kk2));


		vector<int> idx(6); // Translates from "local" indices to "global"
		idx.at(0) =	ii2; // x variables
		idx.at(1) = jj2;
		idx.at(2) = kk2;
		idx.at(3) = ii2 + nVars; // y variables
		idx.at(4) = jj2 + nVars;
		idx.at(5) = kk2 + nVars;

		cout << "ADD_TRIPLET: " << endl;
		cout << "ii:  " << ii <<" " << "jj    " << jj <<" " << "kk :  " << kk << endl;
		cout << "ii2: " << ii2 <<" " << "jj2   " << jj2 <<" " << "kk2 : " << kk2 << endl;

		//	cout <<"outside1:         " << "ii: " << ii <<" " << "jj   " << jj <<" " << "kk : " << kk << endl;

		//dosent exist!
		if(itr != alphaijk.end()){
			cout << "itr != alphaijk.end()" << endl;
			if (itr1 == inserted3.end())
			{
				cout << "itr1 == inserted3.end()" << endl;
				const auto& vec = itr->second;
				for (int j=0;j<gen.ngen3;++j) {
					real alpha = vec.at(j);

					if (alpha > 0){
						cout << "j= " << j << " " << "alpha= " << alpha <<  endl;
					}
					auto& generator = gen.gen3.at(j);
					if (alpha > 0) {
						if (idx.at(generator.indices1.at(0)) == ii && idx.at(generator.indices1.at(1)) ==jj && idx.at(generator.indices1.at(2)) == kk){
							
							cout <<RED <<"ADDED nbr1: "  <<  "ii:  " << ii <<" " << "jj:  " << jj <<" " << "kk:  " << kk << NORMAL <<  endl;
							inserted3.insert(make_pair(make_triple(ii2, jj2, kk2), 1));

							float E1[8];
							add_generators_to_clique(alpha, E1, generator.values1);					
							insert_clique2(poss,E,E1);
							//		for(int i = 0; i < 8; i++)
							//	cout << "i: " << i << "E1[i]: " << E1[i] << endl;
						}
						if (idx.at(generator.indices2.at(0)) == ii && idx.at(generator.indices2.at(1)) ==jj && idx.at(generator.indices2.at(2)) == kk){

							cout <<RED <<"ADDED nbr2: "  <<  "ii:  " << ii <<" " << "jj:  " << jj <<" " << "kk:  " << kk << NORMAL <<  endl;
							inserted3.insert(make_pair(make_triple(ii2, jj2, kk2), 2));

							float E1[8];
							add_generators_to_clique(alpha, E1, generator.values2);					
							insert_clique2(poss,E,E1);
							//		for(int i = 0; i < 8; i++)
							//	cout << "i: " << i << "E1[i]: " << E1[i] << endl;
						}




					}
				}
			}
			//first one is used, add the 2
			else
			{
				if (itr1->second == 1)
				{
					const auto& vec = itr->second;
					for (int j=0;j<gen.ngen3;++j) {
						real alpha = vec.at(j);

						if (alpha > 0){
							cout << "j= " << j << " " << "alpha= " << alpha <<  endl;
						}
						auto& generator = gen.gen3.at(j);
						if (alpha > 0) {
							if (idx.at(generator.indices2.at(0)) == ii && idx.at(generator.indices2.at(1)) ==jj && idx.at(generator.indices2.at(2)) == kk){
								cout <<RED <<"ADDED nbr2: "  <<  "ii:  " << ii <<" " << "jj:  " << jj <<" " << "kk:  " << kk << NORMAL <<  endl;
								itr1->second = 3;

								float E1[8];
								add_generators_to_clique(alpha, E1, generator.values2);					
								insert_clique2(poss,E,E1);
								//		for(int i = 0; i < 8; i++)
								//	cout << "i: " << i << "E1[i]: " << E1[i] << endl;
							}

						}
					}
				}


				if (itr1->second == 2)
				{
					const auto& vec = itr->second;
					for (int j=0;j<gen.ngen3;++j) {
						real alpha = vec.at(j);

						if (alpha > 0){
							cout << "j= " << j << " " << "alpha= " << alpha <<  endl;
						}
						auto& generator = gen.gen3.at(j);
						if (alpha > 0) {
							if (idx.at(generator.indices1.at(0)) == ii && idx.at(generator.indices1.at(1)) ==jj && idx.at(generator.indices1.at(2)) == kk){
								cout <<RED <<"ADDED nbr1: "  <<  "ii:  " << ii <<" " << "jj:  " << jj <<" " << "kk:  " << kk << NORMAL <<  endl;
								itr1->second = 3;

								float E1[8];
								add_generators_to_clique(alpha, E1, generator.values1);					
								insert_clique2(poss,E,E1);
								//		for(int i = 0; i < 8; i++)
								//	cout << "i: " << i << "E1[i]: " << E1[i] << endl;
							}
						}
					}
				}
			}
		}